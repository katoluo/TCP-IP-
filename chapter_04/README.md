# 第4章	基于TCP的服务器端/客户端（1）

TCP是Transmission Control Protocol（传输控制协议）的简写，意为“对数据传输过程的控制”。

#### TCP/IP 协议栈

如图4-1所示：

![图4-1](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_04/images/%E5%9B%BE4-1.png)

TCP/IP协议栈分为4层，各层可能通过操作系统等软件实现，也可能通过类似NIC的硬件设备实现。

> OSI 7 Layer（层）
>
> 数据通信中使用的协议栈分为7层，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

把“通过因特网完成有效数据传输”问题按照不同领域划分成小问题后，出现多种协议，它们通过层级结构建立了紧密联系。



**链路层**

链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。

![图4-4](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_04/images/%E5%9B%BE4-4.png)



**IP层**

准备号物理链接后就要传输数据。为了在复杂的网络中传输数据，首先需要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题就是IP层，该层使用的协议就是IP。

IP本身是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径；但如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。



**TCP/UDP层**

TCP和UDP层以IP层提供的路径信息为基础完成实际的数据传输，又称为传输层。TCP可以保证可靠的数据传输，但它发送数据时以IP层为基础。那该如何理解二者关系呢？

IP层只关注1个数据包（数据传输的基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由IP层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则可能导致后传输的数据包B比先传输的数据包A提前到达。另外，传输的数据包A、B、C中可能只收到A和C，甚至收到的C可能已损毁。反之，若添加TCP协议则按照如下对话进行数据交换。

:one: 主机A：“正确收到第二个数据包！”

:two: 主机B：“恩，知道了。”



:three: 主机A：“正确收到第三个数据包！”

:four: 主机B：“可我已发送第四个数据包了啊！哦，您没收到第四个数据包吧？我给您重传！”

如果数据交换过程中可以确认对方已收到数据，并重传丢失的数据，那么即便IP层不保证数据传输，这类通信也是可靠的，如图4-5所示：

![图4-5](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_04/images/%E5%9B%BE4-5.png)



**应用层**

上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过称都被隐藏到套接字内部。而与其说是“隐藏”，倒不如“使程序员从这些细节中解放出来”的表达更为准确。

编写软件的过程中，需要根据程序特点决定服务器端和客户端之间的数据传输规则，这便是应用层协议。网络编程的大部分内容就是设计并实现应用层协议。



#### 实现基于TCP的服务器端/客户端



**TCP服务器端的默认函数调用顺序**

如图4-6所示：

![图4-6](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_04/images/%E5%9B%BE4-6.png)

调用socket函数创建套接字，声明并初始化地址信息结构体变量，调用bind函数向套接字分配地址。



**进入等待连接请求状态**

我们已调用bind函数给套接字分配了地址，接下来就要通过调用listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出连接请求的状态（客户端才能调用connect函数，不然会发生错误）。

```c
#include <sys/socket.h>
int listen(int sock, int backlog);
/*
 * 成功时返回0。，失败时返回-1
 * sock 希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数称为服务器端套接字（监听套接字）
 * backlog 连接请求等待队列（Queue）的长度
 */
```

客户端连接请求本身也是从网络中接收到的一种数据，而要想接收就需要套接字。此任务就由服务器端套接字完成。



**受理客户端连接请求**

调用listen函数后，若有新的连接请求，则应按序受理。受理请求意味着进入可接收数据的状态。那么我们又需要用到套接字了！大家可能认为可以使用服务器端套接字，但服务器端套接字是做门卫的。如果在与客户端的数据交换中使用门卫，那就没办法受理下一个连接请求并领到等候室去了。因此需要另一个套接字，但没有必要亲自创建。下面函数将自动创建套接字，并连接到发起请求的客户端。

```c
#include <sys/socket.h>
int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);
/*
 * 成功时返回创建的套接字文件描述符，失败时返回-1
 * sock 服务器套接字的文件描述符
 * addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息
 * 
```

accept函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。套接字是自动创建的，并自动与发起连接请求的客户端建立连接。



**TCP客户端的默认函数调用顺序**

创建套接字和请求连接就是客户端的全部内容。与服务器端相比，区别就在于“请求连接“，它是创建客户端套接字后向服务器端发起的连接请求。服务器端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。

```c
#include <sys/socket.h>
int connect(int sock, struct sockaddr *servaddr, socklen_t addrlen);
/*
 * 成功时返回0,失败时返回-1
 * sock 客户端套接字文件描述符
 * servaddr 保存目标服务器端地址信息的变量地址值
 * addrlen 以字节为单位传递给第二个结构体参数servaddr的地址变量长度
 */
```

客户端调用connect函数后，发生一下情况之一才会返回（完成函数调用）。

- 服务器端接收连接请求。
- 发生断网等异常情况而终端连接请求。

需要注意，所谓”接收连接“并不意味着服务器端调用accept函数，起始服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。

> **客户端套接字地址信息在哪？**
>
> 何时？ 调用connect函数时。
>
> 何地？ 操作系统，准确地说实在内核中。
>
> 如何？ IP用计算机的IP，端口随机。
>
> 客户端的IP地址和端口在调用connect函数时自动分配，无需调用标记的bind函数进行分配。



**基于TCP的服务器端/客户端函数调用关系**

如图4-10所示：

![图4-10](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_04/images/%E5%9B%BE4-10.png)



#### 实现迭代服务器端/客户端

本节编写回身（echo）服务器端/客户端。

:one: 服务器端在同一时刻只与一个客户端相连，并提供回身服务。

:two: 服务器端依次向5个客户端提供服务并退出。

:three: 客户端接收用户输入的字符串并发送到服务器端。

:four: 服务器端将接收的字符串数据传回客户端

:five: 服务器端与客户端之间的字符串回声一直执行到客户端输入Q为止。



**实现迭代服务器端/客户端**

[echo_server.c]()

[echo_client.c]()

