# 第5章	基于TCP的服务器端/客户端（2）



#### 回声客户端的完美实现

[echo_client2.c]()



**如果问题不在于回声客户端：定义应用层协议**

回声客户端可以提前知道接收的数据长度，但我们应该意识到，更多情况下这不太可能。既然如此，若无法预知接收数据长度时应如何收发数据？此时需要的就是应用层协议的定义。之前的回声服务器端/客户端中定义了如下协议。

> “收到Q就立即终止连接。”

同样，收发数据过程中也需要定好规则（协议）以表示数据的边界，或提前告知收发数据的大小。服务器端/客户端实现过程中逐步定义的这些规则集合就是应用层协议。可以看出，应用层协议并不是高深莫测的存在，只不过是为特定程序的实现而制定的规则。

下面编写程序以体验应用层协议的定义过程。该程序中，服务器端从客户端获得多个数字和运算符信息。服务器端收到数字后对其进行加减乘运算，然后把结果传回客户端。



**计算器服务器端/客户端示例**

:one: 客户端连接到服务器端后以1字节整数形式传递待算数字个数。

:two: 客户端向服务器端传递的每个整数型数据占4字节。

:three: 传递整数型数据后接着传递运算符。运算符信息占用1字节。

:four: 选择字符+、-、*之一传递。

:five: 服务器端以4字节整型向客户端传回运算结果。

:six: 客户端得到运算结果后终止与服务器端的连接。

这种程度的协议相当于实现了一半程序，这也说明应用层协议设计在网络编程中的重要性。只要设计好协议，实现就不会称为大问题。另外，之前也讲过，调用close函数将向对方传递EOF，请各位记住这一点并加以运用。

客户端源代码：[op_client.c]()

> 第8～10行：将待算数字的字节数和运算结果的字节数设为常数。
>
> 第16行：为收发数据准备的内存空间，需要数据积累到一定程度后再收发，因此通过数组创建。
>
> 第40、41行：从程序用户的输入中得到待算数个数后，保存至数组opmsg。强制转换成char类型，因为协议规定待算数个数应通过1字节整数型传递，因此不能超过1字节整数型能够表示的范围。该示例中用的是有符号整数型，但待算数个数不能是负数，因此使用无符号整数型更合理。
>
> 第43～46行：从程序用户的输入中得到待算整数，保存到数组opmsg。4字节int型数据要保存到char数组，因而转换成int指针类型。若不太理解此部分，应单独复习指针。
>
> 第47行： 第行中需要输入字符，在此之前调用fgetc函数删掉缓冲中的字符\n。
>
> 第49行： 最后输入运算符信息，保存到opmsg数组。
>
> 第50行： 调用write函数一次性传输opmsg数组中的运算相关信息。可以调用1此write函数进行传输，也可以分成多次调用。前面反复强调过，这是因为TCP中不存在数据边界。
>
> 第51行：保存服务器端传输的运算结果。待接收的数据长度为4字节，因此调用1此read函数即可接收。

客户端实现的讲解到此结束，最后给出客户端向服务器端传输的数据结果示例，如图5-1所示。

![图5-1]()

从上图可以看出，若想在同一数组中保存并传输多种数据类型，应把数组声明为char类型。而且需要额外做一些指针及数组运算。接下来给出服务器端代码。

服务器端源代码：[op_server.c]() 

> 第44行：为了接收5个客户端的连接请求而编写的for语句。
>
> 第48行：首先接收算数个数。
>
> 第51～55行：根据第行中的待算数个数接收待算数。
>
> 第56行：调用calculate函数的同时传递待算数的运算符信息参数。
>
> 第57行：向客户端传输calculate函数返回的运算结果。



#### TCP原理

本节内容将称为日后理解套接字选项（第9章）的基础。

**TCP套接字中的I/O缓冲**

TCP套接字的数据收发无边界。服务器端即使调用1此write函数传输40字节的数据，客户端也有可能通过4次read函数调用每次读取10字节。但此处也有一些疑问，服务器端一次性传输了40字节，而客户端居然可以缓慢地分批接收。客户端接收10字节后，剩下的30字节在何处等候呢？是不是像飞机为等待着陆而在空中盘旋一样，剩下30字节也在网络中徘徊并等待接收呢？

实际上，write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。更准确地说，如图5-2所示，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。

![图5-2]()

调用write函数是，数据将移到输出缓冲，在适当的时候（不管是分别传送还是一次性传送）传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据，这些I/O缓冲特性可调整如下。

:one: I/O缓冲在每个TCP套接字中单独存在。

:two: I/O缓冲在创建套接字时自动生成。

:three: 即使关闭套接字也会继续传递输出缓冲中遗留的数据。

:four: 关闭套接字将丢失输入缓冲中的数据。

那么，下面这种情况会引发什么事情？

> “客户端输入缓冲为50字节，而服务器端传输了100字节。”

这的确是个问题，输入缓冲只有50字节，却收到了100字节的数据。可以提出如下解决方案：

> “填满输入缓冲前迅速调用read函数读取数据，这样会腾出一部分空间，问题就解决了。”

当然，这只是一个小玩笑，马上给出结论：

> “不会发生超过输入缓冲大小的数据传输。”

也就是说，根本不会发生这类问题，因为TCP会控制数据流。TCP中有滑动窗口（Sliding Window）协议，用对话方式呈现如下。

:one: 套接字A：“你好，最多可以向我传递50字节。”

:two: 套接字B：“OK！”

:one: 套接字A：“我腾出了20字节的空间，最多可以收70字节。”

:two: 套接字B：“OK！”

数据收发也是如此，因此TCP不会 因为缓冲溢出而丢失数据。



**TCP内部工作原理1：与对方套接字的连接**

TCP套节从创建消失所经过过程分为如下3步。

:one: 与对方套接字建立连接。

:two: 与对方套接字进行数据交换。

:three: 断开与对方套接字的连接。

首先讲解与对象套接字建立连接的过程。连接过程中套接字之间的对话如下。

:one: 套接字A：“你好，套接字B。我这儿有数据要传给你，建立连接吧。”

:two: 套接字B：“好的，我这边已就绪。”

:three: 套接字A：“谢谢你受理我的请求。”

TCP在实际通行过程中也会经过3此对话过程，因此，该过称又称三次握手。接下来给出连接过程中实际交换的信息格式，如图5-3所示。

![图5-3]()

套接字是以全双工（Full-duplex）方式工作的。也就是说，它可以双向传递数据。因此，收发数据前需要做一些准备。首先，请求连接的主机A向主机B传递如下信息：

> [SYN]	SEQ:	1000,	ACK;	-

该消息中SEQ为1000,ACK为空，而SEQ为1000的含义如下：

> 现传递的数据包序号为1000，如果接收无误，请通知我向您传递1001号数据包。“

这是首次请求连接时使用的消息，又称SYN。SYN是Synchronization的简写，表示收发数据前传输的同步消息。接下来主机B向A传递如下消息：

> [SYN+ACK]	SEQ:	2000,	ACK:	1001

此时SEQ为2000,ACK为1001,而SEQ2000的含义如下：

> ”现传递的数据包序号为2000,如果接收无误，请通知我向您传递2001号数据包。“

而ACK 1001的含义如下：

> ”刚才传输的SEQ为1000的数据包接收无误，现在请传递SEQ为1001的数据包。“

对主机A首次传输的数据包的确认消息（ACK 1001）和为主机B传输数据做准备的同步消息（SEQ 2000）捆绑发送，因此，此种类型的消息又称SYN+ACK。

收发数据前向数据分配序号，并向对方通报此序号，这都是为防止数据丢失所做的准备。通过向数据包分配序号并确认，可以在数据丢失时马上查看并重传丢失的数据包。因此，TCP可以保证可靠的数据传输。最后观擦主机A向主机B传输的消息：

> [ACK]	SEQ:	1001,	ACK:	2001

之前也讨论过，TCP连接过称中发送数据包时需分配序号。在之前的序号1000的基础上加1，也就是分配1001.此时该数据包传递如下消息：

> ”已正确收到传输的SEQ为2000的数据包，现在可以传输SEQ为2001的数据包。“

这样就传输了添加ACK 2001的ACK消息。至此，主机A和主机B确认了彼此均就绪。



