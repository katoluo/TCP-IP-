# 第12章	I/O复用

本章将讨论并发服务器的第二种实现方法——基于I。O复用（Multiplexing）的服务器端 构建。虽然通过本章多学习一种服务器端实现方法非常重要，但更重要的是理解每种奇数的优缺点。如果能掌握每种奇数的优劣，就可以根据特定目标灵活应用不同模型，而不是仅关注功能实现。

#### 12.1 基于I/O复用的服务器端

接下来讨论并发服务器实现方法的延伸。如果有读者已经跳过第10章和第11章，那就只需把本章内容当做并发服务器实现的第一种方法即可。将要讨论的内容包含一部分与多进程服务器端的比较，跳过第10章和第11章的读者简单浏览即可。

**多进程服务器端的缺点和解决方法**

为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程时需要付出极大代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要求采用相对复杂的方法（IPC属于相对符炸的通信方法）。各位应该也感到需要IPC时会提高编程难度。

> "那有何解决方案？能否在不创建进程的同时向多个客户端提供服务？"

当然能！本节讲解的I/O复用就是这种技术。大家听到有这种方法是否感到一阵兴奋？但请不要过于依赖该模型！该方案并不适用于所有情况。应当根据目标服务器端的特点采用不同实现方法。下面先理解"复用"（Multiplexing）的意义。

**理解复用**

"复用"在电子及通信工程领域很常见，向这些领域的专家询问其概念时，它恩会亲切地进行如下说明：

> "在1个通信频道中传递多个数据（信号）的技术。"

能理解嘛？不能的话就再看看"复用"的含义。

> "为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。"

上述两种说法内容完全一致，知识描述方式有所区别。下面我根据自己的理解进行解释。图12-1中给出的是纸杯电话，相信大家上小学时也做过。

![图12-1](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-1.png)

图是远距离的3人可以同时通话的3方对话纸杯电话系统。为使3人同时对话，需准备图中所示系统。另外，为了完成3人对话，说话时需要同时对着两个纸杯，接听时也需要耳朵同时对着两个纸杯。此时引入复用奇数会使通话更加方便，如图12-2所示。

![图12-2](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-2.png)

我们上小学时做过类似系统（把先捆在中间并绷直）。构建这种系统就无需同时使用两个杯子，可以说小学就学过"f复用" 的概念了。接下来讨论复用奇数的优点。

:one: 减少连线长度。

:two: 减少纸杯个数。

即使减少了连线和纸杯的量仍能进行3人通话，当然也有人在考虑如下这种情况：

> "好像不能同时说话？"

实际上，因为是在进行对话，所以很少发生同时说话的情况。也就是说，上述系统采用的是"时（time）分复用技术"。而且，因为说话人声高（频率）不同，即使同时说话也能进行一定程度的区分（当然杂音也随之增多）。因此，也可以说系统同时采用了"频（frequency）分复用奇数"。这样大家就能理解之前讲的"复用"的定义了。

**复用技术在服务器端的应用**

纸杯电话系统引入复用技术后，可以减少纸杯数和连线长度。同样，服务器端引入复用技术可以减少所需进程数。未便于比较，献给出第10章的多进程服务器端模型，如图12-3所示。

![图12-3](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-3.png)

上图的模型中引入复用技术，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有1个。

![图12-4](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-4.png)

以上就是I/O复用服务器端模型的讲解，下面考虑通过1个进程向多个客户端提供服务的方法。

#### 12.2 理解select函数并实现服务器端

运用select函数是最具代表性的实现复用服务器端方法。Windows平台下也有同名函数提供相同功能，因此具有良好的移植性。

**select函数的功能和调用顺序**

使用select函数时可以将多个文件描述符集中到一起统一监视，项目如下。

:one: 是否存在套接字接收数据？

:two: 无需阻塞传输数据的套接字有哪些？

:three: 哪些套接字发生了异常？

> 监视项称为"事件"（event）
>
> 上述监视项称为"事件"。发生监视项对应情况时，称为"发生了事件"。这是最常见的表达，希望各位熟悉。另外，本章不会使用术语"时间"，而与本章密切相关的第17章将使用该术语，希望大家理解"事件"的含义，以及"发生事件"的意义。

select函数的使用方法与一般函数区别较大，更准确地说，它很难使用。但为了实现I/O复用服务器端，我们应掌握select函数，并运用到套接字编程中。认为"select函数是I/O复用的全部内容"也并不为过。接下来介绍select函数的调用方法和顺序，如图12-5所示。

![图12-5](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-5.png)

上图给出了从调用select函数到过去结果所经过程。可以看到，调用select函数前需要一些准备工作，调用后还需查看结果。接下来按照上述顺序逐一讲解。

**设置文件描述符**

利用select函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集合到一起。几种时也要按照监视项（接收哦、传输、异常）进行区分，即按照上述3中监视项分成3类。

使用fd_set数组变量执行此项操作，如图12-6所示。该数组是存有0和1的位数组。

![图12-6](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-6.png)

上图中最左端的位表示文件描述符0（所在位置）。如果该位置设置为1,则表示该文件描述符是监视对象。那么图中哪些文件描述符是监视对象呢？很明显，是文件描述符1和3。

> "是否应当通过文件描述符的数字直接将值注册到fd_set变量？"

当然不是！针对fd_set变量的操作是以位为单位进行的，这也一维这直接操作该变量会比较繁琐。难道要求各位自己完成嘛？实际上，在fd_set变量中注册或更改值的操作都由下列宏完成。

:one: FD_ZERO(fd_set *fdset)：将fd_set变量的所有位初始化为0.

:two: FD_SET(int fd, fd_set *fdset)：在参数fdset指向的变量中注册文件描述符fd的信息。

:three: FD_CLR(int fd, fd_set *fdset)：从参数fdset指向的变量中清除文件描述符fd的信息。

:four: FD_ISSET(int fd, fd_set *fdset)：若参数fdset指向的变量中包含文件描述符fd信息，则返回"真"。

上述函数中，FD_ISSET用于验证select函数的调用结果。通过图12-7解释这些函数的功能，简洁易懂，无需赘述。

![图12-7](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-7.png)

设置检查（监视）范围及超时

下面讲解图12-5中步骤以的剩余内容，在此之前先简单介绍select函数。

```c
#include <sys/select.h>
#include <sys/time.h>
int select(
int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, 
const struct timeval *timeout);
/*
 * 成功时返回大于0的值，失败时返回-1
 * maxfd 监视对象文件描述符数量
 * readset 将所有关注"是否存在待读数据"的文件描述符注册到fd_set型变量，并传递其地址值
 * writeset 将所有关注"是否可传输无阻塞数据"的文件按描述符注册到fd_set型变量，并传递其地址值
 * exceptset 将所有关注"是否发生异常"的文件描述符注册到fd_set型变量，并传递其地址值
 * timeout 发生错误时返回-1,超时返回时返回0，。因发生关注的时间返回时，返回大于0的值，该值是发生事件的文件描述符数
 */
```

如上所述，select函数用来验证3中监视项的变化情况。根据监视项声明3个fd_set型变量，分别向其注册文件描述符信息，并把变量的地址值传递到上述函数的第二到第四个参数。但在此之前（调用select函数前）需要决定下面2件事。

> "文件描述符的监视（检查）范围是？"
>
> "如何设定select函数的超时时间？"

第一，文件描述符的监视范围与select函数的第一个参数有关。实际上，select函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在fd_set变量中的文件描述符数。但每次新建文件描述符时，其值都会增1,故只需将最大的文件描述符值加1在传递到select函数即可。加1是因为文件描述符的值从0开始。

第二，select函数的超时时间与select函数的最后一个参数有关，其中timeval结构体定义如下。

```c
struct timeval
{
    long tv_sec;	// seconds
    long tv_usec;	// microseconds
}
```

本来select函数只有在监视的文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了放置这种情况的发生。通过声明上述结构体变量，将秒数填入tv_sec成员，将毫秒数填入tv_usec成员，然后将结构体的地址值传递到select函数的最后一个参数。此时，即使文件描述符中未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下，select函数返回0.因此，可以通过返回值了解返回原因。如果不想设置超时，则传递NULL参数。

**调用select函数后查看结果**

虽未给出具体示例，但图12-5中的步骤一"select函数调用前的所有准备工作"已讲解完毕，同时也介绍了select函数。而函数调用后查看结果也同样重要。我们已讨论过select函数的返回值，如果大于0的整数，说明相应数量的文件描述符发生变化。

> 文件描述符的变化是指监视的文件描述符中发生了相应的监视事件。例如通过select函数的第二个参数传递的集合中存在需要度数据的描述符时，就意味这文件描述符发生变化。

select函数返回正整数时，怎样获知哪些文件描述符发生了方便话？向select函数的第二到第四个参数传递的fd_set变量中将产生如图12-8所示变化，获知过程并不难。

![图12-8](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E5%9B%BE12-8.png)

由上图可知，select函数调用完成后，向其传递的fd_set变量中将发生变化。原来为1的所有位均变为0,但发生变化的文件描述符对应位除外。因此，可以认为值仍为1的位置上的文件描述符发生了变化。

**select函数调用示例**

下面通过示例把select函数所有知识点进行整合，希望各位通过如下示例完全理解之前的内容。

[select.c](https://github.com/katoluo/TCP-IP-Network-Programing/blob/master/chapter_12/select.c)

![运行结果1](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png)

运行后若无任何输入，经过5秒将发生超时。若通过键盘输入字符串，则可看到相同字符串输出。

**实现I/O复用服务器端**

下面通过select函数实现I/O复用服务器端。之前已给出关于select函数的所有说明，各位只需通过示例掌握利用select函数实现服务器端的方法。下列示例是基于I/O复用的回声服务器端。

[echo_selectserv.c](https://github.com/katoluo/TCP-IP-Network-Programing/blob/master/chapter_12/echo_selectserv.c)

![运行结果2](https://github.com/katoluo/TCP-IP-Network-Programing/raw/master/chapter_12/images/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png)

为了验证运行结果，使用了第4章介绍的echo_client.c，起始上述回声客户端也可与其他回声客户端配合运行。